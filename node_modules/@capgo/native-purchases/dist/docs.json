{
  "api": {
    "name": "NativePurchasesPlugin",
    "slug": "nativepurchasesplugin",
    "docs": "",
    "tags": [],
    "methods": [
      {
        "name": "restorePurchases",
        "signature": "() => Promise<void>",
        "parameters": [],
        "returns": "Promise<void>",
        "tags": [],
        "docs": "Restores a user's previous  and links their appUserIDs to any user's also using those .",
        "complexTypes": [],
        "slug": "restorepurchases"
      },
      {
        "name": "getAppTransaction",
        "signature": "() => Promise<{ appTransaction: AppTransaction; }>",
        "parameters": [],
        "returns": "Promise<{ appTransaction: AppTransaction; }>",
        "tags": [
          {
            "name": "returns",
            "text": "The app transaction info"
          },
          {
            "name": "throws",
            "text": "An error if the app transaction cannot be retrieved (iOS 15 or earlier)"
          },
          {
            "name": "since",
            "text": "7.16.0"
          },
          {
            "name": "example",
            "text": "```typescript\nconst { appTransaction } = await NativePurchases.getAppTransaction();\n\n// Check if user downloaded before version 2.0.0 (when subscription was added)\nif (compareVersions(appTransaction.originalAppVersion, '2.0.0') < 0) {\n  // User gets free access - they downloaded before subscriptions\n  grantFreeAccess();\n}\n```"
          },
          {
            "name": "see",
            "text": "https ://developer.apple.com/documentation/storekit/supporting-business-model-changes-by-using-the-app-transaction"
          }
        ],
        "docs": "Gets the App Transaction information, which provides details about when the user\noriginally downloaded or purchased the app.\n\nThis is useful for implementing business model changes where you want to\ngrandfather users who originally downloaded an earlier version of the app.\n\n**Use Case Example:**\nIf your app was originally free but you're adding a subscription, you can use\n`originalAppVersion` to check if users downloaded before the subscription was added\nand give them free access.\n\n**Platform Notes:**\n- **iOS**: Requires iOS 16.0+. Uses StoreKit 2's `AppTransaction.shared`.\n- **Android**: Uses Google Play's install referrer data when available.",
        "complexTypes": [
          "AppTransaction"
        ],
        "slug": "getapptransaction"
      },
      {
        "name": "isEntitledToOldBusinessModel",
        "signature": "(options: { targetVersion?: string; targetBuildNumber?: string; }) => Promise<{ isOlderVersion: boolean; originalAppVersion: string; }>",
        "parameters": [
          {
            "name": "options",
            "docs": "- The comparison options",
            "type": "{ targetVersion?: string | undefined; targetBuildNumber?: string | undefined; }"
          }
        ],
        "returns": "Promise<{ isOlderVersion: boolean; originalAppVersion: string; }>",
        "tags": [
          {
            "name": "param",
            "text": "options - The comparison options"
          },
          {
            "name": "param",
            "text": "options.targetVersion - The Android version name to compare against (e.g., \"2.0.0\"). Used on Android only."
          },
          {
            "name": "param",
            "text": "options.targetBuildNumber - The iOS build number to compare against (e.g., \"42\"). Used on iOS only."
          },
          {
            "name": "returns",
            "text": "- `isOlderVersion`: true if the user's original version is older than target\n- `originalAppVersion`: The user's original app version/build number for reference"
          },
          {
            "name": "throws",
            "text": "An error if the app transaction cannot be retrieved"
          },
          {
            "name": "since",
            "text": "7.16.0"
          },
          {
            "name": "example",
            "text": "```typescript\n// Check if user downloaded before version 2.0.0/build 42 (when subscription was added)\nconst result = await NativePurchases.isEntitledToOldBusinessModel({\n  targetVersion: '2.0.0',\n  targetBuildNumber: '42'\n});\n\nif (result.isOlderVersion) {\n  console.log(`User downloaded v${result.originalAppVersion}, granting free access`);\n  grantFreeAccess();\n}\n```"
          }
        ],
        "docs": "Compares the original app version from the App Transaction against a target version\nto determine if the user is entitled to features from an earlier business model.\n\nThis is a utility method that performs the version comparison natively, which can be\nmore reliable than JavaScript-based comparison for semantic versioning.\n\n**Use Case:**\nCheck if the user's original download version is older than a specific version\nto determine if they should be grandfathered into free features.\n\n**Platform Differences:**\n- iOS: Uses build number (CFBundleVersion) from AppTransaction. Requires iOS 16+.\n- Android: Uses version name from PackageInfo (current installed version, not original).",
        "complexTypes": [],
        "slug": "isentitledtooldbusinessmodel"
      },
      {
        "name": "purchaseProduct",
        "signature": "(options: { productIdentifier: string; planIdentifier?: string; productType?: PURCHASE_TYPE; quantity?: number; appAccountToken?: string; isConsumable?: boolean; autoAcknowledgePurchases?: boolean; }) => Promise<Transaction>",
        "parameters": [
          {
            "name": "options",
            "docs": "- The product to purchase",
            "type": "{ productIdentifier: string; planIdentifier?: string | undefined; productType?: PURCHASE_TYPE | undefined; quantity?: number | undefined; appAccountToken?: string | undefined; isConsumable?: boolean | undefined; autoAcknowledgePurchases?: boolean | undefined; }"
          }
        ],
        "returns": "Promise<Transaction>",
        "tags": [
          {
            "name": "param",
            "text": "options - The product to purchase"
          },
          {
            "name": "param",
            "text": "options.productIdentifier - The product identifier of the product you want to purchase."
          },
          {
            "name": "param",
            "text": "options.productType - Only Android, the type of product, can be inapp or subs. Will use inapp by default."
          },
          {
            "name": "param",
            "text": "options.planIdentifier - Only Android, the identifier of the base plan you want to purchase from Google Play Console. REQUIRED for Android subscriptions, ignored on iOS."
          },
          {
            "name": "param",
            "text": "options.quantity - Only iOS, the number of items you wish to purchase. Will use 1 by default."
          },
          {
            "name": "param",
            "text": "options.appAccountToken - Optional identifier uniquely associated with the user's account in your app.\n  PLATFORM REQUIREMENTS:\n  - iOS: Must be a valid UUID format (StoreKit 2 requirement)\n  - Android: Can be any obfuscated string (max 64 chars), maps to ObfuscatedAccountId\n  SECURITY: DO NOT use PII like emails in cleartext - use UUID or hashed value.\n  RECOMMENDED: Use UUID v5 with deterministic generation for cross-platform compatibility."
          },
          {
            "name": "param",
            "text": "options.isConsumable - Only Android, when true the purchase token is consumed after granting entitlement (for consumable in-app items). Defaults to false."
          },
          {
            "name": "param",
            "text": "options.autoAcknowledgePurchases - When false, the purchase/transaction will NOT be automatically acknowledged/finished. You must manually call acknowledgePurchase() or the purchase may be refunded. Defaults to true.\n  - **Android**: Must acknowledge within 3 days or Google Play will refund\n  - **iOS**: Unfinished transactions remain in the queue and may block future purchases"
          }
        ],
        "docs": "Started purchase process for the given product.",
        "complexTypes": [
          "Transaction",
          "PURCHASE_TYPE"
        ],
        "slug": "purchaseproduct"
      },
      {
        "name": "getProducts",
        "signature": "(options: { productIdentifiers: string[]; productType?: PURCHASE_TYPE; }) => Promise<{ products: Product[]; }>",
        "parameters": [
          {
            "name": "options",
            "docs": "- The product identifiers you wish to retrieve information for",
            "type": "{ productIdentifiers: string[]; productType?: PURCHASE_TYPE | undefined; }"
          }
        ],
        "returns": "Promise<{ products: Product[]; }>",
        "tags": [
          {
            "name": "param",
            "text": "options - The product identifiers you wish to retrieve information for"
          },
          {
            "name": "param",
            "text": "options.productIdentifiers - Array of product identifiers"
          },
          {
            "name": "param",
            "text": "options.productType - Only Android, the type of product, can be inapp or subs. Will use inapp by default."
          },
          {
            "name": "returns",
            "text": "- The requested product info"
          }
        ],
        "docs": "Gets the product info associated with a list of product identifiers.",
        "complexTypes": [
          "Product",
          "PURCHASE_TYPE"
        ],
        "slug": "getproducts"
      },
      {
        "name": "getProduct",
        "signature": "(options: { productIdentifier: string; productType?: PURCHASE_TYPE; }) => Promise<{ product: Product; }>",
        "parameters": [
          {
            "name": "options",
            "docs": "- The product identifier you wish to retrieve information for",
            "type": "{ productIdentifier: string; productType?: PURCHASE_TYPE | undefined; }"
          }
        ],
        "returns": "Promise<{ product: Product; }>",
        "tags": [
          {
            "name": "param",
            "text": "options - The product identifier you wish to retrieve information for"
          },
          {
            "name": "param",
            "text": "options.productIdentifier - The product identifier"
          },
          {
            "name": "param",
            "text": "options.productType - Only Android, the type of product, can be inapp or subs. Will use inapp by default."
          },
          {
            "name": "returns",
            "text": "- The requested product info"
          }
        ],
        "docs": "Gets the product info for a single product identifier.",
        "complexTypes": [
          "Product",
          "PURCHASE_TYPE"
        ],
        "slug": "getproduct"
      },
      {
        "name": "isBillingSupported",
        "signature": "() => Promise<{ isBillingSupported: boolean; }>",
        "parameters": [],
        "returns": "Promise<{ isBillingSupported: boolean; }>",
        "tags": [],
        "docs": "Check if billing is supported for the current device.",
        "complexTypes": [],
        "slug": "isbillingsupported"
      },
      {
        "name": "getPluginVersion",
        "signature": "() => Promise<{ version: string; }>",
        "parameters": [],
        "returns": "Promise<{ version: string; }>",
        "tags": [
          {
            "name": "returns",
            "text": "an Promise with version for this device"
          },
          {
            "name": "throws",
            "text": "An error if the something went wrong"
          }
        ],
        "docs": "Get the native Capacitor plugin version",
        "complexTypes": [],
        "slug": "getpluginversion"
      },
      {
        "name": "getPurchases",
        "signature": "(options?: { productType?: PURCHASE_TYPE | undefined; appAccountToken?: string | undefined; } | undefined) => Promise<{ purchases: Transaction[]; }>",
        "parameters": [
          {
            "name": "options",
            "docs": "- Optional parameters for filtering purchases",
            "type": "{ productType?: PURCHASE_TYPE | undefined; appAccountToken?: string | undefined; } | undefined"
          }
        ],
        "returns": "Promise<{ purchases: Transaction[]; }>",
        "tags": [
          {
            "name": "param",
            "text": "options - Optional parameters for filtering purchases"
          },
          {
            "name": "param",
            "text": "options.productType - Only Android, filter by product type (inapp or subs). If not specified, returns both types."
          },
          {
            "name": "param",
            "text": "options.appAccountToken - Optional filter to restrict results to purchases that used the provided account token.\n   Must be the same identifier used during purchase (UUID format for iOS, any obfuscated string for Android).\n   iOS: UUID format required. Android: Maps to ObfuscatedAccountId."
          },
          {
            "name": "returns",
            "text": "Promise that resolves with array of user's purchases"
          },
          {
            "name": "throws",
            "text": "An error if the purchase query fails"
          },
          {
            "name": "since",
            "text": "7.2.0"
          }
        ],
        "docs": "Gets all the user's purchases (both in-app purchases and subscriptions).\nThis method queries the platform's purchase history for the current user.",
        "complexTypes": [
          "Transaction",
          "PURCHASE_TYPE"
        ],
        "slug": "getpurchases"
      },
      {
        "name": "manageSubscriptions",
        "signature": "() => Promise<void>",
        "parameters": [],
        "returns": "Promise<void>",
        "tags": [
          {
            "name": "returns",
            "text": "Promise that resolves when the management page is opened"
          },
          {
            "name": "throws",
            "text": "An error if the subscription management page cannot be opened"
          },
          {
            "name": "since",
            "text": "7.10.0"
          }
        ],
        "docs": "Opens the platform's native subscription management page.\nThis allows users to view, modify, or cancel their subscriptions.\n\n- iOS: Opens the App Store subscription management page for the current app\n- Android: Opens the Google Play subscription management page",
        "complexTypes": [],
        "slug": "managesubscriptions"
      },
      {
        "name": "acknowledgePurchase",
        "signature": "(options: { purchaseToken: string; }) => Promise<void>",
        "parameters": [
          {
            "name": "options",
            "docs": "- The purchase to acknowledge",
            "type": "{ purchaseToken: string; }"
          }
        ],
        "returns": "Promise<void>",
        "tags": [
          {
            "name": "param",
            "text": "options - The purchase to acknowledge"
          },
          {
            "name": "param",
            "text": "options.purchaseToken - The purchase token (Android) or transaction ID as string (iOS) from the Transaction object"
          },
          {
            "name": "returns",
            "text": "Promise that resolves when the purchase is acknowledged/finished"
          },
          {
            "name": "throws",
            "text": "An error if acknowledgment/finishing fails or transaction not found"
          },
          {
            "name": "platform",
            "text": "android Acknowledges the purchase with Google Play"
          },
          {
            "name": "platform",
            "text": "ios Finishes the transaction with StoreKit 2"
          },
          {
            "name": "since",
            "text": "7.14.0"
          },
          {
            "name": "example",
            "text": "```typescript\n// Client-side acknowledgment\nconst transaction = await NativePurchases.purchaseProduct({\n  productIdentifier: 'premium_feature',\n  autoAcknowledgePurchases: false\n});\n\n// Validate with your backend\nconst isValid = await fetch('/api/validate-purchase', {\n  method: 'POST',\n  body: JSON.stringify({ purchaseToken: transaction.purchaseToken })\n});\n\nif (isValid) {\n  // Option 1: Acknowledge from client\n  await NativePurchases.acknowledgePurchase({\n    purchaseToken: transaction.purchaseToken\n  });\n\n  // Option 2: Or let your backend acknowledge via Google Play API\n  // Your backend calls Google Play Developer API\n}\n```"
          }
        ],
        "docs": "Manually acknowledge/finish a purchase transaction.\n\nThis method is only needed when you set `autoAcknowledgePurchases: false` in purchaseProduct().\n\n**Platform Behavior:**\n- **Android**: Acknowledges the purchase with Google Play. Must be called within 3 days or the purchase will be refunded.\n- **iOS**: Finishes the transaction with StoreKit 2. Unfinished transactions remain in the queue and may block future purchases.\n\n**Acknowledgment Options:**\n\n**1. Client-side (this method)**: Call from your app after validation\n```typescript\nawait NativePurchases.acknowledgePurchase({\n  purchaseToken: transaction.purchaseToken  // Android: purchaseToken, iOS: transactionId\n});\n```\n\n**2. Server-side (Android only, recommended for security)**: Use Google Play Developer API v3\n- Endpoint: `POST https://androidpublisher.googleapis.com/androidpublisher/v3/applications/{packageName}/purchases/products/{productId}/tokens/{token}:acknowledge`\n- Requires OAuth 2.0 authentication with appropriate scopes\n- See: https://developers.google.com/android-publisher/api-ref/rest/v3/purchases.products/acknowledge\n- For subscriptions: Use `/purchases/subscriptions/{subscriptionId}/tokens/{token}:acknowledge` instead\n- Note: iOS has no server-side finish API\n\n**When to use manual acknowledgment:**\n- Server-side validation: Verify the purchase with your backend before acknowledging\n- Entitlement delivery: Ensure user receives content/features before acknowledging\n- Multi-step workflows: Complete all steps before final acknowledgment\n- Security: Prevent client-side manipulation by handling acknowledgment server-side (Android only)",
        "complexTypes": [],
        "slug": "acknowledgepurchase"
      },
      {
        "name": "addListener",
        "signature": "(eventName: 'transactionUpdated', listenerFunc: (transaction: Transaction) => void) => Promise<PluginListenerHandle>",
        "parameters": [
          {
            "name": "eventName",
            "docs": "",
            "type": "'transactionUpdated'"
          },
          {
            "name": "listenerFunc",
            "docs": "",
            "type": "(transaction: Transaction) => void"
          }
        ],
        "returns": "Promise<PluginListenerHandle>",
        "tags": [],
        "docs": "Listen for StoreKit transaction updates delivered by Apple's Transaction.updates.\nFires on app launch if there are unfinished transactions, and for any updates afterward.\niOS only.",
        "complexTypes": [
          "PluginListenerHandle",
          "Transaction"
        ],
        "slug": "addlistenertransactionupdated-"
      },
      {
        "name": "addListener",
        "signature": "(eventName: 'transactionVerificationFailed', listenerFunc: (payload: TransactionVerificationFailedEvent) => void) => Promise<PluginListenerHandle>",
        "parameters": [
          {
            "name": "eventName",
            "docs": "",
            "type": "'transactionVerificationFailed'"
          },
          {
            "name": "listenerFunc",
            "docs": "",
            "type": "(payload: TransactionVerificationFailedEvent) => void"
          }
        ],
        "returns": "Promise<PluginListenerHandle>",
        "tags": [],
        "docs": "Listen for StoreKit transaction verification failures delivered by Apple's Transaction.updates.\nFires when the verification result is unverified.\niOS only.",
        "complexTypes": [
          "PluginListenerHandle",
          "TransactionVerificationFailedEvent"
        ],
        "slug": "addlistenertransactionverificationfailed-"
      },
      {
        "name": "removeAllListeners",
        "signature": "() => Promise<void>",
        "parameters": [],
        "returns": "Promise<void>",
        "tags": [],
        "docs": "Remove all registered listeners",
        "complexTypes": [],
        "slug": "removealllisteners"
      }
    ],
    "properties": []
  },
  "interfaces": [
    {
      "name": "AppTransaction",
      "slug": "apptransaction",
      "docs": "Represents the App Transaction information from StoreKit 2.\nThis provides details about when the user originally downloaded or purchased the app,\nwhich is useful for determining if users are entitled to features from earlier business models.",
      "tags": [
        {
          "text": "https ://developer.apple.com/documentation/storekit/supporting-business-model-changes-by-using-the-app-transaction",
          "name": "see"
        },
        {
          "text": "7.16.0",
          "name": "since"
        }
      ],
      "methods": [],
      "properties": [
        {
          "name": "originalAppVersion",
          "tags": [
            {
              "text": "\"1.0.0\"",
              "name": "example"
            },
            {
              "text": "7.16.0",
              "name": "since"
            },
            {
              "text": "ios Always present (iOS 16+)",
              "name": "platform"
            },
            {
              "text": "android Always present",
              "name": "platform"
            }
          ],
          "docs": "The app version that the user originally purchased or downloaded.\n\nUse this to determine if users who originally downloaded an earlier version\nshould be entitled to features that were previously free or included.\n\nFor iOS: This is the `CFBundleShortVersionString` (e.g., \"1.0.0\")\nFor Android: This is the `versionName` from Google Play (e.g., \"1.0.0\")",
          "complexTypes": [],
          "type": "string"
        },
        {
          "name": "originalPurchaseDate",
          "tags": [
            {
              "text": "\"2023-06-15T10:30:00Z\"",
              "name": "example"
            },
            {
              "text": "7.16.0",
              "name": "since"
            },
            {
              "text": "ios Always present (iOS 16+)",
              "name": "platform"
            },
            {
              "text": "android Always present",
              "name": "platform"
            }
          ],
          "docs": "The date when the user originally purchased or downloaded the app.\nISO 8601 format.",
          "complexTypes": [],
          "type": "string"
        },
        {
          "name": "bundleId",
          "tags": [
            {
              "text": "\"com.example.myapp\"",
              "name": "example"
            },
            {
              "text": "7.16.0",
              "name": "since"
            },
            {
              "text": "ios Always present (iOS 16+)",
              "name": "platform"
            },
            {
              "text": "android Always present (package name)",
              "name": "platform"
            }
          ],
          "docs": "The bundle identifier of the app.",
          "complexTypes": [],
          "type": "string"
        },
        {
          "name": "appVersion",
          "tags": [
            {
              "text": "\"2.0.0\"",
              "name": "example"
            },
            {
              "text": "7.16.0",
              "name": "since"
            },
            {
              "text": "ios Always present",
              "name": "platform"
            },
            {
              "text": "android Always present",
              "name": "platform"
            }
          ],
          "docs": "The current app version installed on the device.",
          "complexTypes": [],
          "type": "string"
        },
        {
          "name": "environment",
          "tags": [
            {
              "text": "7.16.0",
              "name": "since"
            },
            {
              "text": "ios Present (iOS 16+)",
              "name": "platform"
            },
            {
              "text": "android Not available (always null)",
              "name": "platform"
            }
          ],
          "docs": "The server environment where the app was originally purchased.",
          "complexTypes": [],
          "type": "'Sandbox' | 'Production' | 'Xcode' | null | undefined"
        },
        {
          "name": "jwsRepresentation",
          "tags": [
            {
              "text": "7.16.0",
              "name": "since"
            },
            {
              "text": "ios Present (iOS 16+)",
              "name": "platform"
            },
            {
              "text": "android Not available",
              "name": "platform"
            }
          ],
          "docs": "The JWS (JSON Web Signature) representation of the app transaction.\nCan be sent to your backend for server-side verification.",
          "complexTypes": [],
          "type": "string | undefined"
        }
      ]
    },
    {
      "name": "Transaction",
      "slug": "transaction",
      "docs": "",
      "tags": [],
      "methods": [],
      "properties": [
        {
          "name": "transactionId",
          "tags": [
            {
              "text": "1.0.0",
              "name": "since"
            },
            {
              "text": "ios Numeric string (e.g., \"2000001043762129\")",
              "name": "platform"
            },
            {
              "text": "android Alphanumeric string (e.g., \"GPA.1234-5678-9012-34567\")",
              "name": "platform"
            }
          ],
          "docs": "Unique identifier for the transaction.",
          "complexTypes": [],
          "type": "string"
        },
        {
          "name": "receipt",
          "tags": [
            {
              "text": "1.0.0",
              "name": "since"
            },
            {
              "text": "ios Always present",
              "name": "platform"
            },
            {
              "text": "android Not available (use purchaseToken instead)",
              "name": "platform"
            },
            {
              "text": "```typescript\nconst transaction = await NativePurchases.purchaseProduct({ ... });\nif (transaction.receipt) {\n  // Send to your backend for validation\n  await fetch('/api/validate-receipt', {\n    method: 'POST',\n    body: JSON.stringify({ receipt: transaction.receipt })\n  });\n}\n```",
              "name": "example"
            }
          ],
          "docs": "Receipt data for validation (base64 encoded StoreKit receipt).\n\n**This is the full verified receipt payload from Apple StoreKit.**\nSend this to your backend for server-side validation with Apple's receipt verification API.\nThe receipt remains available even after refund - server validation is required to detect refunded transactions.\n\n**For backend validation:**\n- Use Apple's receipt verification API: https://buy.itunes.apple.com/verifyReceipt (production)\n- Or sandbox: https://sandbox.itunes.apple.com/verifyReceipt\n- This contains all transaction data needed for validation\n\n**Note:** Apple recommends migrating to App Store Server API v2 with `jwsRepresentation` for new implementations.\nThe legacy receipt verification API continues to work but may be deprecated in the future.",
          "complexTypes": [],
          "type": "string | undefined"
        },
        {
          "name": "jwsRepresentation",
          "tags": [
            {
              "text": "7.13.2",
              "name": "since"
            },
            {
              "text": "ios Present for StoreKit 2 transactions (iOS 15+)",
              "name": "platform"
            },
            {
              "text": "android Not available",
              "name": "platform"
            },
            {
              "text": "```typescript\nconst transaction = await NativePurchases.purchaseProduct({ ... });\nif (transaction.jwsRepresentation) {\n  // Send to your backend for validation with App Store Server API v2\n  await fetch('/api/validate-jws', {\n    method: 'POST',\n    body: JSON.stringify({ jws: transaction.jwsRepresentation })\n  });\n}\n```",
              "name": "example"
            }
          ],
          "docs": "StoreKit 2 JSON Web Signature (JWS) payload describing the verified transaction.\n\n**This is the full verified receipt in JWS format (StoreKit 2).**\nSend this to your backend when using Apple's App Store Server API v2 instead of raw receipts.\nOnly available when the transaction originated from StoreKit 2 APIs (e.g. Transaction.updates).\n\n**For backend validation:**\n- Use Apple's App Store Server API v2 to decode and verify the JWS\n- This is the modern alternative to the legacy receipt format\n- Contains signed transaction information from Apple",
          "complexTypes": [],
          "type": "string | undefined"
        },
        {
          "name": "appAccountToken",
          "tags": [],
          "docs": "An optional obfuscated identifier that uniquely associates the transaction with a user account in your app.\n\nPURPOSE:\n- Fraud detection: Helps platforms detect irregular activity (e.g., many devices purchasing on the same account)\n- User linking: Links purchases to in-game characters, avatars, or in-app profiles\n\nPLATFORM DIFFERENCES:\n- iOS: Must be a valid UUID format (e.g., \"550e8400-e29b-41d4-a716-446655440000\")\n       Apple's StoreKit 2 requires UUID format for the appAccountToken parameter\n- Android: Can be any obfuscated string (max 64 chars), maps to Google Play's ObfuscatedAccountId\n          Google recommends using encryption or one-way hash\n\nSECURITY REQUIREMENTS (especially for Android):\n- DO NOT store Personally Identifiable Information (PII) like emails in cleartext\n- Use encryption or a one-way hash to generate an obfuscated identifier\n- Maximum length: 64 characters (both platforms)\n- Storing PII in cleartext will result in purchases being blocked by Google Play\n\nIMPLEMENTATION EXAMPLE:\n```typescript\n// For iOS: Generate a deterministic UUID from user ID\nimport { v5 as uuidv5 } from 'uuid';\nconst NAMESPACE = '6ba7b810-9dad-11d1-80b4-00c04fd430c8'; // Your app's namespace UUID\nconst appAccountToken = uuidv5(userId, NAMESPACE);\n\n// For Android: Can also use UUID or any hashed value\n// The same UUID approach works for both platforms\n```",
          "complexTypes": [],
          "type": "string | null | undefined"
        },
        {
          "name": "productIdentifier",
          "tags": [
            {
              "text": "1.0.0",
              "name": "since"
            },
            {
              "text": "ios Always present",
              "name": "platform"
            },
            {
              "text": "android Always present",
              "name": "platform"
            }
          ],
          "docs": "Product identifier associated with the transaction.",
          "complexTypes": [],
          "type": "string"
        },
        {
          "name": "purchaseDate",
          "tags": [
            {
              "text": "1.0.0",
              "name": "since"
            },
            {
              "text": "\"2025-10-28T06:03:19Z\"",
              "name": "example"
            },
            {
              "text": "ios Always present",
              "name": "platform"
            },
            {
              "text": "android Always present",
              "name": "platform"
            }
          ],
          "docs": "Purchase date of the transaction in ISO 8601 format.",
          "complexTypes": [],
          "type": "string"
        },
        {
          "name": "isUpgraded",
          "tags": [
            {
              "text": "7.13.2",
              "name": "since"
            },
            {
              "text": "ios Present for auto-renewable subscriptions (iOS 15+)",
              "name": "platform"
            },
            {
              "text": "android Not available",
              "name": "platform"
            }
          ],
          "docs": "Indicates whether this transaction is the result of a subscription upgrade.\n\nUseful for understanding when StoreKit generated the transaction because\nthe customer moved from a lower tier to a higher tier plan.",
          "complexTypes": [],
          "type": "boolean | undefined"
        },
        {
          "name": "originalPurchaseDate",
          "tags": [
            {
              "text": "1.0.0",
              "name": "since"
            },
            {
              "text": "ios Present for subscriptions only",
              "name": "platform"
            },
            {
              "text": "android Not available",
              "name": "platform"
            }
          ],
          "docs": "Original purchase date of the transaction in ISO 8601 format.\n\nFor subscription renewals, this shows the date of the original subscription purchase,\nwhile purchaseDate shows the date of the current renewal.",
          "complexTypes": [],
          "type": "string | undefined"
        },
        {
          "name": "expirationDate",
          "tags": [
            {
              "text": "1.0.0",
              "name": "since"
            },
            {
              "text": "ios Present for subscriptions only",
              "name": "platform"
            },
            {
              "text": "android Not available (query Google Play Developer API instead)",
              "name": "platform"
            }
          ],
          "docs": "Expiration date of the transaction in ISO 8601 format.\n\nCheck this date to determine if a subscription is still valid.\nCompare with current date: if expirationDate > now, subscription is active.",
          "complexTypes": [],
          "type": "string | undefined"
        },
        {
          "name": "isActive",
          "tags": [
            {
              "text": "1.0.0",
              "name": "since"
            },
            {
              "text": "ios Present for subscriptions only (true if expiration date is in the future)",
              "name": "platform"
            },
            {
              "text": "android Not available (check purchaseState === \"1\" instead)",
              "name": "platform"
            }
          ],
          "docs": "Whether the subscription is still active/valid.\n\nFor iOS subscriptions, check if isActive === true to verify an active subscription.\nFor expired or refunded iOS subscriptions, this will be false.",
          "complexTypes": [],
          "type": "boolean | undefined"
        },
        {
          "name": "revocationDate",
          "tags": [
            {
              "text": "7.13.2",
              "name": "since"
            },
            {
              "text": "ios Present for revoked transactions (iOS 15+)",
              "name": "platform"
            },
            {
              "text": "android Not available",
              "name": "platform"
            }
          ],
          "docs": "Date the transaction was revoked/refunded, in ISO 8601 format.\n\nPresent when Apple revokes access due to an issue (e.g., refund or developer issue).",
          "complexTypes": [],
          "type": "string | undefined"
        },
        {
          "name": "revocationReason",
          "tags": [
            {
              "text": "7.13.2",
              "name": "since"
            },
            {
              "text": "ios Present for revoked transactions (iOS 15+)",
              "name": "platform"
            },
            {
              "text": "android Not available",
              "name": "platform"
            }
          ],
          "docs": "Reason why Apple revoked the transaction.\n\nPossible values:\n- `\"developerIssue\"`: Developer-initiated refund or issue\n- `\"other\"`: Apple-initiated (customer refund, billing problem, etc.)\n- `\"unknown\"`: StoreKit didn't report a specific reason",
          "complexTypes": [],
          "type": "'developerIssue' | 'other' | 'unknown' | undefined"
        },
        {
          "name": "willCancel",
          "tags": [
            {
              "text": "1.0.0",
              "name": "since"
            },
            {
              "text": "null",
              "name": "default"
            },
            {
              "text": "ios Present for subscriptions only (boolean or null)",
              "name": "platform"
            },
            {
              "text": "android Always null (use Google Play Developer API for cancellation status)",
              "name": "platform"
            }
          ],
          "docs": "Whether the subscription will be cancelled at the end of the billing cycle.\n\n- `true`: User has cancelled but subscription remains active until expiration\n- `false`: Subscription will auto-renew\n- `null`: Status unknown or not available",
          "complexTypes": [],
          "type": "boolean | null"
        },
        {
          "name": "subscriptionState",
          "tags": [
            {
              "text": "7.13.2",
              "name": "since"
            },
            {
              "text": "ios Present for auto-renewable subscriptions (iOS 15+)",
              "name": "platform"
            },
            {
              "text": "android Not available",
              "name": "platform"
            }
          ],
          "docs": "Current subscription state reported by StoreKit.\n\nPossible values:\n- `\"subscribed\"`: Auto-renewing and in good standing\n- `\"expired\"`: Lapsed with no access\n- `\"revoked\"`: Access removed due to refund or issue\n- `\"inGracePeriod\"`: Payment issue but still in grace access window\n- `\"inBillingRetryPeriod\"`: StoreKit retrying failed billing\n- `\"unknown\"`: StoreKit did not report a state",
          "complexTypes": [],
          "type": "'unknown' | 'subscribed' | 'expired' | 'revoked' | 'inGracePeriod' | 'inBillingRetryPeriod' | undefined"
        },
        {
          "name": "purchaseState",
          "tags": [
            {
              "text": "1.0.0",
              "name": "since"
            },
            {
              "text": "ios Not available (use isActive for subscriptions or receipt validation for IAP)",
              "name": "platform"
            },
            {
              "text": "android Always present",
              "name": "platform"
            }
          ],
          "docs": "Purchase state of the transaction (numeric string value).\n\n**Android Values:**\n- `\"1\"`: Purchase completed and valid (PURCHASED state)\n- `\"0\"`: Payment pending (PENDING state, e.g., cash payment processing)\n- Other numeric values: Various other states\n\nAlways check `purchaseState === \"1\"` on Android to verify a valid purchase.\nRefunded purchases typically disappear from getPurchases() rather than showing a different state.",
          "complexTypes": [],
          "type": "string | undefined"
        },
        {
          "name": "orderId",
          "tags": [
            {
              "text": "1.0.0",
              "name": "since"
            },
            {
              "text": "\"GPA.1234-5678-9012-34567\"",
              "name": "example"
            },
            {
              "text": "ios Not available",
              "name": "platform"
            },
            {
              "text": "android Always present",
              "name": "platform"
            }
          ],
          "docs": "Order ID associated with the transaction.\n\nUse this for server-side verification on Android. This is the Google Play order ID.",
          "complexTypes": [],
          "type": "string | undefined"
        },
        {
          "name": "purchaseToken",
          "tags": [
            {
              "text": "1.0.0",
              "name": "since"
            },
            {
              "text": "ios Not available (use receipt instead)",
              "name": "platform"
            },
            {
              "text": "android Always present",
              "name": "platform"
            },
            {
              "text": "```typescript\nconst transaction = await NativePurchases.purchaseProduct({ ... });\nif (transaction.purchaseToken) {\n  // Send to your backend for validation\n  await fetch('/api/validate-purchase', {\n    method: 'POST',\n    body: JSON.stringify({\n      purchaseToken: transaction.purchaseToken,\n      productId: transaction.productIdentifier\n    })\n  });\n}\n```",
              "name": "example"
            }
          ],
          "docs": "Purchase token associated with the transaction.\n\n**This is the full verified purchase token from Google Play.**\nSend this to your backend for server-side validation with Google Play Developer API.\nThis is the Android equivalent of iOS's receipt field.\n\n**For backend validation:**\n- Use Google Play Developer API v3 to verify the purchase\n- API endpoint: androidpublisher.purchases.products.get() or purchases.subscriptions.get()\n- This token contains all data needed for validation with Google servers\n- Can also be used for subscription status checks and cancellation detection",
          "complexTypes": [],
          "type": "string | undefined"
        },
        {
          "name": "isAcknowledged",
          "tags": [
            {
              "text": "1.0.0",
              "name": "since"
            },
            {
              "text": "ios Not available",
              "name": "platform"
            },
            {
              "text": "android Always present (should be true after successful purchase or manual acknowledgment)",
              "name": "platform"
            }
          ],
          "docs": "Whether the purchase has been acknowledged.\n\nPurchases must be acknowledged within 3 days or they will be refunded.\nBy default, this plugin automatically acknowledges purchases unless you set\n`autoAcknowledgePurchases: false` in purchaseProduct().",
          "complexTypes": [],
          "type": "boolean | undefined"
        },
        {
          "name": "quantity",
          "tags": [
            {
              "text": "1.0.0",
              "name": "since"
            },
            {
              "text": "1",
              "name": "default"
            },
            {
              "text": "ios 1 or higher (as specified in purchaseProduct call)",
              "name": "platform"
            },
            {
              "text": "android Always 1 (Google Play doesn't support quantity > 1)",
              "name": "platform"
            }
          ],
          "docs": "Quantity purchased.",
          "complexTypes": [],
          "type": "number | undefined"
        },
        {
          "name": "productType",
          "tags": [
            {
              "text": "1.0.0",
              "name": "since"
            },
            {
              "text": "ios Always present",
              "name": "platform"
            },
            {
              "text": "android Always present",
              "name": "platform"
            }
          ],
          "docs": "Product type.\n\n- `\"inapp\"`: One-time in-app purchase\n- `\"subs\"`: Subscription",
          "complexTypes": [],
          "type": "string | undefined"
        },
        {
          "name": "ownershipType",
          "tags": [
            {
              "text": "7.12.8",
              "name": "since"
            },
            {
              "text": "ios Always present (iOS 15.0+, StoreKit 2)",
              "name": "platform"
            },
            {
              "text": "android Not available",
              "name": "platform"
            }
          ],
          "docs": "Indicates how the user obtained access to the product.\n\n- `\"purchased\"`: The user purchased the product directly\n- `\"familyShared\"`: The user has access through Family Sharing (another family member purchased it)\n\nThis property is useful for:\n- Detecting family sharing usage for analytics\n- Implementing different features/limits for family-shared vs. directly purchased products\n- Understanding your user acquisition channels",
          "complexTypes": [],
          "type": "'purchased' | 'familyShared' | undefined"
        },
        {
          "name": "environment",
          "tags": [
            {
              "text": "7.12.8",
              "name": "since"
            },
            {
              "text": "ios Present on iOS 16.0+ only (not available on iOS 15)",
              "name": "platform"
            },
            {
              "text": "android Not available",
              "name": "platform"
            }
          ],
          "docs": "Indicates the server environment where the transaction was processed.\n\n- `\"Sandbox\"`: Transaction belongs to testing in the sandbox environment\n- `\"Production\"`: Transaction belongs to a customer in the production environment\n- `\"Xcode\"`: Transaction from StoreKit Testing in Xcode\n\nThis property is useful for:\n- Debugging and identifying test vs. production purchases\n- Analytics and reporting (filtering out sandbox transactions)\n- Server-side validation (knowing which Apple endpoint to use)\n- Preventing test purchases from affecting production metrics",
          "complexTypes": [],
          "type": "'Sandbox' | 'Production' | 'Xcode' | undefined"
        },
        {
          "name": "transactionReason",
          "tags": [
            {
              "text": "7.13.2",
              "name": "since"
            },
            {
              "text": "ios Present on iOS 17.0+ (StoreKit 2 transactions)",
              "name": "platform"
            },
            {
              "text": "android Not available",
              "name": "platform"
            }
          ],
          "docs": "Reason StoreKit generated the transaction.\n\n- `\"purchase\"`: Initial purchase that user made manually\n- `\"renewal\"`: Automatically generated renewal for an auto-renewable subscription\n- `\"unknown\"`: StoreKit did not return a reason",
          "complexTypes": [],
          "type": "'unknown' | 'purchase' | 'renewal' | undefined"
        },
        {
          "name": "isTrialPeriod",
          "tags": [
            {
              "text": "1.0.0",
              "name": "since"
            },
            {
              "text": "ios Present for subscriptions with trial offers",
              "name": "platform"
            },
            {
              "text": "android Present for subscriptions with trial offers",
              "name": "platform"
            }
          ],
          "docs": "Whether the transaction is in a trial period.\n\n- `true`: Currently in free trial period\n- `false`: Not in trial period",
          "complexTypes": [],
          "type": "boolean | undefined"
        },
        {
          "name": "isInIntroPricePeriod",
          "tags": [
            {
              "text": "1.0.0",
              "name": "since"
            },
            {
              "text": "ios Present for subscriptions with intro pricing",
              "name": "platform"
            },
            {
              "text": "android Present for subscriptions with intro pricing",
              "name": "platform"
            }
          ],
          "docs": "Whether the transaction is in an introductory price period.\n\nIntroductory pricing is a discounted rate, different from a free trial.\n\n- `true`: Currently using introductory pricing\n- `false`: Not in intro period",
          "complexTypes": [],
          "type": "boolean | undefined"
        },
        {
          "name": "isInGracePeriod",
          "tags": [
            {
              "text": "1.0.0",
              "name": "since"
            },
            {
              "text": "ios Present for subscriptions in grace period",
              "name": "platform"
            },
            {
              "text": "android Present for subscriptions in grace period",
              "name": "platform"
            }
          ],
          "docs": "Whether the transaction is in a grace period.\n\nGrace period allows users to fix payment issues while maintaining access.\nYou typically want to continue providing access during this time.\n\n- `true`: Subscription payment failed but user still has access\n- `false`: Not in grace period",
          "complexTypes": [],
          "type": "boolean | undefined"
        }
      ]
    },
    {
      "name": "Product",
      "slug": "product",
      "docs": "",
      "tags": [],
      "methods": [],
      "properties": [
        {
          "name": "identifier",
          "tags": [],
          "docs": "Product Id.",
          "complexTypes": [],
          "type": "string"
        },
        {
          "name": "description",
          "tags": [],
          "docs": "Description of the product.",
          "complexTypes": [],
          "type": "string"
        },
        {
          "name": "title",
          "tags": [],
          "docs": "Title of the product.",
          "complexTypes": [],
          "type": "string"
        },
        {
          "name": "price",
          "tags": [],
          "docs": "Price of the product in the local currency.",
          "complexTypes": [],
          "type": "number"
        },
        {
          "name": "priceString",
          "tags": [],
          "docs": "Formatted price of the item, including its currency sign, such as â‚¬3.99.",
          "complexTypes": [],
          "type": "string"
        },
        {
          "name": "currencyCode",
          "tags": [],
          "docs": "Currency code for price and original price.",
          "complexTypes": [],
          "type": "string"
        },
        {
          "name": "currencySymbol",
          "tags": [],
          "docs": "Currency symbol for price and original price.",
          "complexTypes": [],
          "type": "string"
        },
        {
          "name": "isFamilyShareable",
          "tags": [],
          "docs": "Boolean indicating if the product is sharable with family",
          "complexTypes": [],
          "type": "boolean"
        },
        {
          "name": "subscriptionGroupIdentifier",
          "tags": [],
          "docs": "Group identifier for the product.",
          "complexTypes": [],
          "type": "string"
        },
        {
          "name": "subscriptionPeriod",
          "tags": [],
          "docs": "The Product subscription group identifier.",
          "complexTypes": [
            "SubscriptionPeriod"
          ],
          "type": "SubscriptionPeriod"
        },
        {
          "name": "introductoryPrice",
          "tags": [],
          "docs": "The Product introductory Price.",
          "complexTypes": [
            "SKProductDiscount"
          ],
          "type": "SKProductDiscount | null"
        },
        {
          "name": "discounts",
          "tags": [],
          "docs": "The Product discounts list.",
          "complexTypes": [
            "SKProductDiscount"
          ],
          "type": "SKProductDiscount[]"
        }
      ]
    },
    {
      "name": "SubscriptionPeriod",
      "slug": "subscriptionperiod",
      "docs": "",
      "tags": [],
      "methods": [],
      "properties": [
        {
          "name": "numberOfUnits",
          "tags": [],
          "docs": "The Subscription Period number of unit.",
          "complexTypes": [],
          "type": "number"
        },
        {
          "name": "unit",
          "tags": [],
          "docs": "The Subscription Period unit.",
          "complexTypes": [],
          "type": "number"
        }
      ]
    },
    {
      "name": "SKProductDiscount",
      "slug": "skproductdiscount",
      "docs": "",
      "tags": [],
      "methods": [],
      "properties": [
        {
          "name": "identifier",
          "tags": [],
          "docs": "The Product discount identifier.",
          "complexTypes": [],
          "type": "string"
        },
        {
          "name": "type",
          "tags": [],
          "docs": "The Product discount type.",
          "complexTypes": [],
          "type": "number"
        },
        {
          "name": "price",
          "tags": [],
          "docs": "The Product discount price.",
          "complexTypes": [],
          "type": "number"
        },
        {
          "name": "priceString",
          "tags": [],
          "docs": "Formatted price of the item, including its currency sign, such as â‚¬3.99.",
          "complexTypes": [],
          "type": "string"
        },
        {
          "name": "currencySymbol",
          "tags": [],
          "docs": "The Product discount currency symbol.",
          "complexTypes": [],
          "type": "string"
        },
        {
          "name": "currencyCode",
          "tags": [],
          "docs": "The Product discount currency code.",
          "complexTypes": [],
          "type": "string"
        },
        {
          "name": "paymentMode",
          "tags": [],
          "docs": "The Product discount paymentMode.",
          "complexTypes": [],
          "type": "number"
        },
        {
          "name": "numberOfPeriods",
          "tags": [],
          "docs": "The Product discount number Of Periods.",
          "complexTypes": [],
          "type": "number"
        },
        {
          "name": "subscriptionPeriod",
          "tags": [],
          "docs": "The Product discount subscription period.",
          "complexTypes": [
            "SubscriptionPeriod"
          ],
          "type": "SubscriptionPeriod"
        }
      ]
    },
    {
      "name": "PluginListenerHandle",
      "slug": "pluginlistenerhandle",
      "docs": "",
      "tags": [],
      "methods": [],
      "properties": [
        {
          "name": "remove",
          "tags": [],
          "docs": "",
          "complexTypes": [],
          "type": "() => Promise<void>"
        }
      ]
    },
    {
      "name": "TransactionVerificationFailedEvent",
      "slug": "transactionverificationfailedevent",
      "docs": "",
      "tags": [],
      "methods": [],
      "properties": [
        {
          "name": "transactionId",
          "tags": [
            {
              "text": "7.13.2",
              "name": "since"
            },
            {
              "text": "ios Present when StoreKit reports an unverified transaction",
              "name": "platform"
            },
            {
              "text": "android Not available",
              "name": "platform"
            }
          ],
          "docs": "Identifier of the transaction that failed verification.",
          "complexTypes": [],
          "type": "string"
        },
        {
          "name": "error",
          "tags": [
            {
              "text": "7.13.2",
              "name": "since"
            },
            {
              "text": "ios Always present",
              "name": "platform"
            },
            {
              "text": "android Not available",
              "name": "platform"
            }
          ],
          "docs": "Localized error message describing why verification failed.",
          "complexTypes": [],
          "type": "string"
        }
      ]
    }
  ],
  "enums": [
    {
      "name": "PURCHASE_TYPE",
      "slug": "purchase_type",
      "members": [
        {
          "name": "INAPP",
          "value": "'inapp'",
          "tags": [],
          "docs": "A type of SKU for in-app products."
        },
        {
          "name": "SUBS",
          "value": "'subs'",
          "tags": [],
          "docs": "A type of SKU for subscriptions."
        }
      ]
    }
  ],
  "typeAliases": [],
  "pluginConfigs": []
}